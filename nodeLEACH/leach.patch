diff --git a/README.md b/README.md
index 58f2040..8cbf2d9 100644
--- a/README.md
+++ b/README.md
@@ -1,22 +1,12 @@
-# Node implementation for modified LEACH protocol
- This repo will contain needed files for nodes in modified LEACH protocol.
+# node
+ This repo will contain needed files for nodes in LEACH protocol.
  
  Nodes will decide on their own if they are cluster head for current round or not.
- Decision will be made based if node was cluster head in any round before, distance to base station
- and threshold. If random number is less that threshold, then node will become cluster head for current round.
- Fictive number of nodes is calculated where signal strength is calculated, as per formula below:
- 
- Nf = round( -N * RSSI/100)
- 
- where N is true number of nodes in network, RSSI is signal strength towards base station.
- 
+ Decision will be made based if node was cluster head before and random number between 0 and 1.
+ If random number is less that threshold, then node will become cluster head for current round.
  Threshold is calculated per formula below:
 
-  T = P/(1 - P * (r % 1/P));
-  
-  r - current round, P = 1/Nf.
+  T = P/(1 - P*(r % 1/P));
   
-  Where P is probability that there will be 1 node as cluster head in Nf rounds, 
-  r is current round. Nodes will calculate threshold only if they were not 
-  cluster heads in previous rounds. Rounds reset after Nf-1 number of rounds, 
-  where node can become cluster head again.
\ No newline at end of file
+  Where P is determined apriori, r is current round. Nodes will calculate
+  threshold only if they were not cluster heads in previous rounds.
\ No newline at end of file
diff --git a/node/functions.cpp b/node/functions.cpp
index 7166866..c6d6078 100644
--- a/node/functions.cpp
+++ b/node/functions.cpp
@@ -15,8 +15,9 @@
  *  will be kept.*/
 const char *filename = "/conf.txt";
 
-/** Probability that node will be cluster head for current round.*/
-float Prob = 1/NUMBER_OF_NODES;
+/** Probability that node will be cluster head for current round.
+ *  Determined apriori, depends of number of nodes.*/
+const float P = 0.2;
 
 /** This is the address of base station.*/
 const IPAddress base_station(192,168,4,1);
@@ -36,7 +37,6 @@ IPAddress ch_address;
 /**This node name.*/
 char node_name[10];
 
-/** One of ID`s which define node.*/
 unsigned char number_of_node;
 
 /** Strongest valid network.*/
@@ -48,13 +48,8 @@ uint32_t apIP;
 /** This variable holds time when cycle started in miliseconds.*/
 unsigned long cycle_start;
 
-/** This variable will track fictive number of nodes due to algorithm change.*/
-unsigned char modified_node_number = NUMBER_OF_NODES;
-
-/** Holds the value for how long node will wait before sending ADC value.*/
 char SLEEP_STRING[10];
 
-/** Needed for UDP functionalities.*/
 WiFiUDP Udp;
 
 #if DEBUG
@@ -190,108 +185,6 @@ const char* create_node_id (void)
   return node;
 }
 
-float update_probability(float n)
-{
-  float p = 10;
-  
-  p = 1/n;
-
-  return p;
-}
-
-bool modify_N(unsigned char p)
-{
-  bool ret = false;
-
-  modified_node_number = round((NUMBER_OF_NODES * p)/100);
-
-#if DEBUG
-  Serial.print("Modified number of nodes = ");
-  Serial.println(modified_node_number);
-#endif
-
-  if ((modified_node_number < 1) && (modified_node_number >= 0)){
-    modified_node_number = 1;
-  }
-
-  if (modified_node_number >= 0) {
-
-    Prob = update_probability(modified_node_number);
-
-#if DEBUG
-    Serial.print("Updated probability = ");
-    Serial.println(Prob, 3);
-#endif
-    
-    ret = true;
-  }
-
-#if DEBUG
-  Serial.print("Modified number of nodes after change = ");
-  Serial.println(modified_node_number);
-#endif
-
-  return ret;
-}
-
-void base_signal_strength(void)
-{
-  unsigned char n;
-  int power;
-  bool changed;
-  bool base_found = false;
-
-  n = WiFi.scanNetworks();
-
-  if (n == 0){
-
-#if DEBUG
-    Serial.println("Did not find any networks at all!");
-    Serial.println("Going to sleep ...");
-#endif
-
-    sleeping_time();
-  }
-  else {
-    for (int i = 0; i < n; i++) {
-      if (WiFi.SSID(i) == BASE_SSID) {
-
-        base_found = true;
-        power = -WiFi.RSSI(i);
-        changed = modify_N(power);
-
-#if DEBUG
-        Serial.print("Base SSID = ");
-        Serial.println(WiFi.SSID(i));
-        Serial.print("Signal strength = ");
-        Serial.println(WiFi.RSSI(i));
-#endif
-
-#if DEBUG
-        if (changed == true) {
-          Serial.println("Successfully changed modified number of nodes!");  
-        }
-        else {
-          Serial.println("Could not change modified number of nodes!");
-        }
-#endif
-
-      }
-      delay(20);
-    }
-
-    if (base_found == false) {
-
-#if DEBUG
-      Serial.println("Could not find base!");
-#endif
-      
-      sleeping_time();
-    }
-    
-  }
-}
-
 void strongest_ch_ssid(void)
 { 
   unsigned char n;
@@ -317,8 +210,8 @@ void strongest_ch_ssid(void)
     power = WiFi.RSSI(0);
     strongest = WiFi.SSID(0);
 
-    for (int i = 0; i < n; ++i) {      
-      if (check_ch(WiFi.SSID(i).c_str()) > 0) {
+    for (int i = 0; i < n; ++i) {
+     if (check_ch(WiFi.SSID(i).c_str()) > 0) {
         if (WiFi.RSSI(i) > power) {
           power = WiFi.RSSI(i);
           strongest = WiFi.SSID(i);
@@ -1010,7 +903,7 @@ void wifi_connect(unsigned char CH)
 void full_circle(unsigned char *round_cnt, unsigned char *ch_enable)
 { 
   *round_cnt += 1;
-  if (*round_cnt > modified_node_number - 1)
+  if (*round_cnt > NUMBER_OF_NODES - 1)
   {
     *round_cnt = 0;
     *ch_enable = 1;
@@ -1031,7 +924,7 @@ unsigned char cluster_head(unsigned char *round_cnt, unsigned char *ch_enable)
   unsigned char ret;
 
   rnd_nmb = random_number();
-  threshold = calculate_threshold(*round_cnt);
+  threshold = calculate_threshold(P, *round_cnt);
 
   if ((rnd_nmb < threshold) && (*ch_enable == 1)) {
     *ch_enable = 0;
@@ -1108,11 +1001,11 @@ void read_fs(unsigned char *round_cnt, unsigned char *ch)
 #endif
 }
 
-float calculate_threshold(unsigned char r)
+float calculate_threshold(float P, unsigned char r)
 {
   float T;
 
-  T = Prob/(1 - Prob*(r % ((unsigned char)round(1/Prob))));
+  T = P/(1 - P*(r % ((unsigned char)round(1/P))));
 
 #if DEBUG
   Serial.print("r = ");
diff --git a/node/includes.h b/node/includes.h
index e875b8f..6e88770 100644
--- a/node/includes.h
+++ b/node/includes.h
@@ -28,7 +28,7 @@
 #define ROUND_RESET               0
 
 /**Maximum number of nodes in network*/
-#define NUMBER_OF_NODES           7
+#define NUMBER_OF_NODES           5
 
 /** String length for round to be writen to filesystem.*/
 #define ROUND_NUMBER_LENGTH       2
@@ -128,30 +128,6 @@ typedef enum
   NODE6
 } nodes;
 
-/**  
- * @brief Updates probability that node will be cluster head.
- * @param Fictive number of nodes.
- * @return Updated probability.
- * 
- */
-float update_probability(float n);
-
-/**  
- * @brief Calculates fictive number of nodes.
- * @param Signal strength to base.
- * @return True if update was successful.
- * 
- */
-bool modify_N(unsigned char p);
-
-/**  
- * @brief Scanes network for BASE_SSID.
- * @param none.
- * @return none.
- * 
- */
-void base_signal_strength(void);
-
 /**  
  * @brief Check if received message from broadcast port contains
  * value for this node 
@@ -329,7 +305,7 @@ bool mount_fs(void);
  * @param r Current round.
  * @return Returns threshold for current round.
  */
-float calculate_threshold(unsigned char r);
+float calculate_threshold(float P, unsigned char r);
 
 /**
  * @brief Generates random number between 0 and 1.
diff --git a/node/node.ino b/node/node.ino
index 19b2729..cdb1ae3 100644
--- a/node/node.ino
+++ b/node/node.ino
@@ -36,8 +36,6 @@ void setup()
     read_fs(&round_cnt, &ch_enable);
   }
 
-  base_signal_strength();
-
   CH = cluster_head(&round_cnt, &ch_enable);
 
   if (CH == CLUSTER_HEAD) {
